Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    Illegal_Lexeme

Grammar

Rule 0     S' -> start
Rule 1     start -> PROGRAM_KW IDENTIFIER SEMICOLON decList funcList block
Rule 2     decList -> decs
Rule 3     decList -> decs decList
Rule 4     decs -> type varList SEMICOLON
Rule 5     decs -> empty
Rule 6     type -> INTEGER_KW
Rule 7     type -> REAL_KW
Rule 8     type -> BOOLEAN_KW
Rule 9     varList -> IDENTIFIER
Rule 10    varList -> varList COMMA IDENTIFIER
Rule 11    funcList -> funcList funcDec
Rule 12    funcList -> empty
Rule 13    funcDec -> FUNCTION_KW IDENTIFIER parameters COLON type decList block
Rule 14    parameters -> LEFT_PA decList RIGHT_PA
Rule 15    block -> BEGIN_KW stmtList END_KW
Rule 16    stmtList -> stmt
Rule 17    stmtList -> stmt stmtList
Rule 18    stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON
Rule 19    stmt -> IF_KW expr THEN_KW stmt
Rule 20    stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt
Rule 21    stmt -> WHILE_KW expr DO_KW stmt
Rule 22    stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt
Rule 23    stmt -> RETURN_KW expr SEMICOLON
Rule 24    stmt -> block
Rule 25    expr -> expr AND_KW expr
Rule 26    expr -> expr OR_KW expr
Rule 27    expr -> expr MUL_OP expr
Rule 28    expr -> expr DIV_OP expr
Rule 29    expr -> expr ADD_OP expr
Rule 30    expr -> expr SUB_OP expr
Rule 31    expr -> expr relop expr
Rule 32    expr -> LEFT_PA expr RIGHT_PA
Rule 33    expr -> INTEGER_NUMBER
Rule 34    expr -> REAL_NUMBER
Rule 35    expr -> TRUE_KW
Rule 36    expr -> FALSE_KW
Rule 37    expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
Rule 38    expr -> IDENTIFIER
Rule 39    actualparamlist -> expr
Rule 40    actualparamlist -> actualparamlist COMMA expr
Rule 41    actualparamlist -> empty
Rule 42    relop -> LT_OP
Rule 43    relop -> LE_OP
Rule 44    relop -> EQ_OP
Rule 45    relop -> NE_OP
Rule 46    relop -> GE_OP
Rule 47    relop -> GT_OP
Rule 48    empty -> <empty>

Terminals, with rules where they appear

ADD_OP               : 29
AND_KW               : 25
ASSIGN_OP            : 18 22
BEGIN_KW             : 15
BOOLEAN_KW           : 8
COLON                : 13
COMMA                : 10 40
DIV_OP               : 28
DO_KW                : 21 22
ELSE_KW              : 20
END_KW               : 15
EQ_OP                : 44
FALSE_KW             : 36
FOR_KW               : 22
FUNCTION_KW          : 13
GE_OP                : 46
GT_OP                : 47
IDENTIFIER           : 1 9 10 13 18 22 37 38
IF_KW                : 19 20
INTEGER_KW           : 6
INTEGER_NUMBER       : 33
Illegal_Lexeme       : 
LEFT_PA              : 14 32 37
LE_OP                : 43
LT_OP                : 42
MUL_OP               : 27
NE_OP                : 45
OR_KW                : 26
PROGRAM_KW           : 1
REAL_KW              : 7
REAL_NUMBER          : 34
RETURN_KW            : 23
RIGHT_PA             : 14 32 37
SEMICOLON            : 1 4 18 23
SUB_OP               : 30
THEN_KW              : 19 20
TO_KW                : 22
TRUE_KW              : 35
WHILE_KW             : 21
error                : 

Nonterminals, with rules where they appear

actualparamlist      : 37 40
block                : 1 13 24
decList              : 1 3 13 14
decs                 : 2 3
empty                : 5 12 41
expr                 : 18 19 20 21 22 22 23 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 39 40
funcDec              : 11
funcList             : 1 11
parameters           : 13
relop                : 31
start                : 0
stmt                 : 16 17 19 20 20 21 22
stmtList             : 15 17
type                 : 4 13
varList              : 4 10

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PROGRAM_KW IDENTIFIER SEMICOLON decList funcList block

    PROGRAM_KW      shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PROGRAM_KW . IDENTIFIER SEMICOLON decList funcList block

    IDENTIFIER      shift and go to state 3


state 3

    (1) start -> PROGRAM_KW IDENTIFIER . SEMICOLON decList funcList block

    SEMICOLON       shift and go to state 4


state 4

    (1) start -> PROGRAM_KW IDENTIFIER SEMICOLON . decList funcList block
    (2) decList -> . decs
    (3) decList -> . decs decList
    (4) decs -> . type varList SEMICOLON
    (5) decs -> . empty
    (6) type -> . INTEGER_KW
    (7) type -> . REAL_KW
    (8) type -> . BOOLEAN_KW
    (48) empty -> .

  ! shift/reduce conflict for INTEGER_KW resolved as shift
  ! shift/reduce conflict for REAL_KW resolved as shift
  ! shift/reduce conflict for BOOLEAN_KW resolved as shift
    INTEGER_KW      shift and go to state 9
    REAL_KW         shift and go to state 10
    BOOLEAN_KW      shift and go to state 11
    BEGIN_KW        reduce using rule 48 (empty -> .)
    FUNCTION_KW     reduce using rule 48 (empty -> .)

  ! INTEGER_KW      [ reduce using rule 48 (empty -> .) ]
  ! REAL_KW         [ reduce using rule 48 (empty -> .) ]
  ! BOOLEAN_KW      [ reduce using rule 48 (empty -> .) ]

    decList                        shift and go to state 5
    decs                           shift and go to state 6
    type                           shift and go to state 7
    empty                          shift and go to state 8

state 5

    (1) start -> PROGRAM_KW IDENTIFIER SEMICOLON decList . funcList block
    (11) funcList -> . funcList funcDec
    (12) funcList -> . empty
    (48) empty -> .

    BEGIN_KW        reduce using rule 48 (empty -> .)
    FUNCTION_KW     reduce using rule 48 (empty -> .)

    funcList                       shift and go to state 12
    empty                          shift and go to state 13

state 6

    (2) decList -> decs .
    (3) decList -> decs . decList
    (2) decList -> . decs
    (3) decList -> . decs decList
    (4) decs -> . type varList SEMICOLON
    (5) decs -> . empty
    (6) type -> . INTEGER_KW
    (7) type -> . REAL_KW
    (8) type -> . BOOLEAN_KW
    (48) empty -> .

  ! shift/reduce conflict for INTEGER_KW resolved as shift
  ! shift/reduce conflict for REAL_KW resolved as shift
  ! shift/reduce conflict for BOOLEAN_KW resolved as shift
  ! reduce/reduce conflict for BEGIN_KW resolved using rule 2 (decList -> decs .)
  ! reduce/reduce conflict for FUNCTION_KW resolved using rule 2 (decList -> decs .)
  ! reduce/reduce conflict for RIGHT_PA resolved using rule 2 (decList -> decs .)
    BEGIN_KW        reduce using rule 2 (decList -> decs .)
    FUNCTION_KW     reduce using rule 2 (decList -> decs .)
    RIGHT_PA        reduce using rule 2 (decList -> decs .)
    INTEGER_KW      shift and go to state 9
    REAL_KW         shift and go to state 10
    BOOLEAN_KW      shift and go to state 11

  ! INTEGER_KW      [ reduce using rule 48 (empty -> .) ]
  ! REAL_KW         [ reduce using rule 48 (empty -> .) ]
  ! BOOLEAN_KW      [ reduce using rule 48 (empty -> .) ]
  ! BEGIN_KW        [ reduce using rule 48 (empty -> .) ]
  ! FUNCTION_KW     [ reduce using rule 48 (empty -> .) ]
  ! RIGHT_PA        [ reduce using rule 48 (empty -> .) ]

    decs                           shift and go to state 6
    decList                        shift and go to state 14
    type                           shift and go to state 7
    empty                          shift and go to state 8

state 7

    (4) decs -> type . varList SEMICOLON
    (9) varList -> . IDENTIFIER
    (10) varList -> . varList COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 16

    varList                        shift and go to state 15

state 8

    (5) decs -> empty .

    INTEGER_KW      reduce using rule 5 (decs -> empty .)
    REAL_KW         reduce using rule 5 (decs -> empty .)
    BOOLEAN_KW      reduce using rule 5 (decs -> empty .)
    BEGIN_KW        reduce using rule 5 (decs -> empty .)
    FUNCTION_KW     reduce using rule 5 (decs -> empty .)
    RIGHT_PA        reduce using rule 5 (decs -> empty .)


state 9

    (6) type -> INTEGER_KW .

    IDENTIFIER      reduce using rule 6 (type -> INTEGER_KW .)
    INTEGER_KW      reduce using rule 6 (type -> INTEGER_KW .)
    REAL_KW         reduce using rule 6 (type -> INTEGER_KW .)
    BOOLEAN_KW      reduce using rule 6 (type -> INTEGER_KW .)
    BEGIN_KW        reduce using rule 6 (type -> INTEGER_KW .)


state 10

    (7) type -> REAL_KW .

    IDENTIFIER      reduce using rule 7 (type -> REAL_KW .)
    INTEGER_KW      reduce using rule 7 (type -> REAL_KW .)
    REAL_KW         reduce using rule 7 (type -> REAL_KW .)
    BOOLEAN_KW      reduce using rule 7 (type -> REAL_KW .)
    BEGIN_KW        reduce using rule 7 (type -> REAL_KW .)


state 11

    (8) type -> BOOLEAN_KW .

    IDENTIFIER      reduce using rule 8 (type -> BOOLEAN_KW .)
    INTEGER_KW      reduce using rule 8 (type -> BOOLEAN_KW .)
    REAL_KW         reduce using rule 8 (type -> BOOLEAN_KW .)
    BOOLEAN_KW      reduce using rule 8 (type -> BOOLEAN_KW .)
    BEGIN_KW        reduce using rule 8 (type -> BOOLEAN_KW .)


state 12

    (1) start -> PROGRAM_KW IDENTIFIER SEMICOLON decList funcList . block
    (11) funcList -> funcList . funcDec
    (15) block -> . BEGIN_KW stmtList END_KW
    (13) funcDec -> . FUNCTION_KW IDENTIFIER parameters COLON type decList block

    BEGIN_KW        shift and go to state 19
    FUNCTION_KW     shift and go to state 20

    block                          shift and go to state 17
    funcDec                        shift and go to state 18

state 13

    (12) funcList -> empty .

    BEGIN_KW        reduce using rule 12 (funcList -> empty .)
    FUNCTION_KW     reduce using rule 12 (funcList -> empty .)


state 14

    (3) decList -> decs decList .

    BEGIN_KW        reduce using rule 3 (decList -> decs decList .)
    FUNCTION_KW     reduce using rule 3 (decList -> decs decList .)
    RIGHT_PA        reduce using rule 3 (decList -> decs decList .)


state 15

    (4) decs -> type varList . SEMICOLON
    (10) varList -> varList . COMMA IDENTIFIER

    SEMICOLON       shift and go to state 21
    COMMA           shift and go to state 22


state 16

    (9) varList -> IDENTIFIER .

    SEMICOLON       reduce using rule 9 (varList -> IDENTIFIER .)
    COMMA           reduce using rule 9 (varList -> IDENTIFIER .)


state 17

    (1) start -> PROGRAM_KW IDENTIFIER SEMICOLON decList funcList block .

    $end            reduce using rule 1 (start -> PROGRAM_KW IDENTIFIER SEMICOLON decList funcList block .)


state 18

    (11) funcList -> funcList funcDec .

    BEGIN_KW        reduce using rule 11 (funcList -> funcList funcDec .)
    FUNCTION_KW     reduce using rule 11 (funcList -> funcList funcDec .)


state 19

    (15) block -> BEGIN_KW . stmtList END_KW
    (16) stmtList -> . stmt
    (17) stmtList -> . stmt stmtList
    (18) stmt -> . IDENTIFIER ASSIGN_OP expr SEMICOLON
    (19) stmt -> . IF_KW expr THEN_KW stmt
    (20) stmt -> . IF_KW expr THEN_KW stmt ELSE_KW stmt
    (21) stmt -> . WHILE_KW expr DO_KW stmt
    (22) stmt -> . FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt
    (23) stmt -> . RETURN_KW expr SEMICOLON
    (24) stmt -> . block
    (15) block -> . BEGIN_KW stmtList END_KW

    IDENTIFIER      shift and go to state 25
    IF_KW           shift and go to state 26
    WHILE_KW        shift and go to state 27
    FOR_KW          shift and go to state 28
    RETURN_KW       shift and go to state 29
    BEGIN_KW        shift and go to state 19

    stmtList                       shift and go to state 23
    stmt                           shift and go to state 24
    block                          shift and go to state 30

state 20

    (13) funcDec -> FUNCTION_KW . IDENTIFIER parameters COLON type decList block

    IDENTIFIER      shift and go to state 31


state 21

    (4) decs -> type varList SEMICOLON .

    INTEGER_KW      reduce using rule 4 (decs -> type varList SEMICOLON .)
    REAL_KW         reduce using rule 4 (decs -> type varList SEMICOLON .)
    BOOLEAN_KW      reduce using rule 4 (decs -> type varList SEMICOLON .)
    BEGIN_KW        reduce using rule 4 (decs -> type varList SEMICOLON .)
    FUNCTION_KW     reduce using rule 4 (decs -> type varList SEMICOLON .)
    RIGHT_PA        reduce using rule 4 (decs -> type varList SEMICOLON .)


state 22

    (10) varList -> varList COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 32


state 23

    (15) block -> BEGIN_KW stmtList . END_KW

    END_KW          shift and go to state 33


state 24

    (16) stmtList -> stmt .
    (17) stmtList -> stmt . stmtList
    (16) stmtList -> . stmt
    (17) stmtList -> . stmt stmtList
    (18) stmt -> . IDENTIFIER ASSIGN_OP expr SEMICOLON
    (19) stmt -> . IF_KW expr THEN_KW stmt
    (20) stmt -> . IF_KW expr THEN_KW stmt ELSE_KW stmt
    (21) stmt -> . WHILE_KW expr DO_KW stmt
    (22) stmt -> . FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt
    (23) stmt -> . RETURN_KW expr SEMICOLON
    (24) stmt -> . block
    (15) block -> . BEGIN_KW stmtList END_KW

    END_KW          reduce using rule 16 (stmtList -> stmt .)
    IDENTIFIER      shift and go to state 25
    IF_KW           shift and go to state 26
    WHILE_KW        shift and go to state 27
    FOR_KW          shift and go to state 28
    RETURN_KW       shift and go to state 29
    BEGIN_KW        shift and go to state 19

    stmt                           shift and go to state 24
    stmtList                       shift and go to state 34
    block                          shift and go to state 30

state 25

    (18) stmt -> IDENTIFIER . ASSIGN_OP expr SEMICOLON

    ASSIGN_OP       shift and go to state 35


state 26

    (19) stmt -> IF_KW . expr THEN_KW stmt
    (20) stmt -> IF_KW . expr THEN_KW stmt ELSE_KW stmt
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 36

state 27

    (21) stmt -> WHILE_KW . expr DO_KW stmt
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 43

state 28

    (22) stmt -> FOR_KW . IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt

    IDENTIFIER      shift and go to state 44


state 29

    (23) stmt -> RETURN_KW . expr SEMICOLON
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 45

state 30

    (24) stmt -> block .

    IDENTIFIER      reduce using rule 24 (stmt -> block .)
    IF_KW           reduce using rule 24 (stmt -> block .)
    WHILE_KW        reduce using rule 24 (stmt -> block .)
    FOR_KW          reduce using rule 24 (stmt -> block .)
    RETURN_KW       reduce using rule 24 (stmt -> block .)
    BEGIN_KW        reduce using rule 24 (stmt -> block .)
    END_KW          reduce using rule 24 (stmt -> block .)
    ELSE_KW         reduce using rule 24 (stmt -> block .)


state 31

    (13) funcDec -> FUNCTION_KW IDENTIFIER . parameters COLON type decList block
    (14) parameters -> . LEFT_PA decList RIGHT_PA

    LEFT_PA         shift and go to state 47

    parameters                     shift and go to state 46

state 32

    (10) varList -> varList COMMA IDENTIFIER .

    SEMICOLON       reduce using rule 10 (varList -> varList COMMA IDENTIFIER .)
    COMMA           reduce using rule 10 (varList -> varList COMMA IDENTIFIER .)


state 33

    (15) block -> BEGIN_KW stmtList END_KW .

    $end            reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    IDENTIFIER      reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    IF_KW           reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    WHILE_KW        reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    FOR_KW          reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    RETURN_KW       reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    BEGIN_KW        reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    END_KW          reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    ELSE_KW         reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)
    FUNCTION_KW     reduce using rule 15 (block -> BEGIN_KW stmtList END_KW .)


state 34

    (17) stmtList -> stmt stmtList .

    END_KW          reduce using rule 17 (stmtList -> stmt stmtList .)


state 35

    (18) stmt -> IDENTIFIER ASSIGN_OP . expr SEMICOLON
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 48

state 36

    (19) stmt -> IF_KW expr . THEN_KW stmt
    (20) stmt -> IF_KW expr . THEN_KW stmt ELSE_KW stmt
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    THEN_KW         shift and go to state 49
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 37

    (32) expr -> LEFT_PA . expr RIGHT_PA
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 63

state 38

    (33) expr -> INTEGER_NUMBER .

    THEN_KW         reduce using rule 33 (expr -> INTEGER_NUMBER .)
    AND_KW          reduce using rule 33 (expr -> INTEGER_NUMBER .)
    OR_KW           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    MUL_OP          reduce using rule 33 (expr -> INTEGER_NUMBER .)
    DIV_OP          reduce using rule 33 (expr -> INTEGER_NUMBER .)
    ADD_OP          reduce using rule 33 (expr -> INTEGER_NUMBER .)
    SUB_OP          reduce using rule 33 (expr -> INTEGER_NUMBER .)
    LT_OP           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    LE_OP           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    EQ_OP           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    NE_OP           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    GE_OP           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    GT_OP           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    DO_KW           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    SEMICOLON       reduce using rule 33 (expr -> INTEGER_NUMBER .)
    RIGHT_PA        reduce using rule 33 (expr -> INTEGER_NUMBER .)
    COMMA           reduce using rule 33 (expr -> INTEGER_NUMBER .)
    TO_KW           reduce using rule 33 (expr -> INTEGER_NUMBER .)


state 39

    (34) expr -> REAL_NUMBER .

    THEN_KW         reduce using rule 34 (expr -> REAL_NUMBER .)
    AND_KW          reduce using rule 34 (expr -> REAL_NUMBER .)
    OR_KW           reduce using rule 34 (expr -> REAL_NUMBER .)
    MUL_OP          reduce using rule 34 (expr -> REAL_NUMBER .)
    DIV_OP          reduce using rule 34 (expr -> REAL_NUMBER .)
    ADD_OP          reduce using rule 34 (expr -> REAL_NUMBER .)
    SUB_OP          reduce using rule 34 (expr -> REAL_NUMBER .)
    LT_OP           reduce using rule 34 (expr -> REAL_NUMBER .)
    LE_OP           reduce using rule 34 (expr -> REAL_NUMBER .)
    EQ_OP           reduce using rule 34 (expr -> REAL_NUMBER .)
    NE_OP           reduce using rule 34 (expr -> REAL_NUMBER .)
    GE_OP           reduce using rule 34 (expr -> REAL_NUMBER .)
    GT_OP           reduce using rule 34 (expr -> REAL_NUMBER .)
    DO_KW           reduce using rule 34 (expr -> REAL_NUMBER .)
    SEMICOLON       reduce using rule 34 (expr -> REAL_NUMBER .)
    RIGHT_PA        reduce using rule 34 (expr -> REAL_NUMBER .)
    COMMA           reduce using rule 34 (expr -> REAL_NUMBER .)
    TO_KW           reduce using rule 34 (expr -> REAL_NUMBER .)


state 40

    (35) expr -> TRUE_KW .

    THEN_KW         reduce using rule 35 (expr -> TRUE_KW .)
    AND_KW          reduce using rule 35 (expr -> TRUE_KW .)
    OR_KW           reduce using rule 35 (expr -> TRUE_KW .)
    MUL_OP          reduce using rule 35 (expr -> TRUE_KW .)
    DIV_OP          reduce using rule 35 (expr -> TRUE_KW .)
    ADD_OP          reduce using rule 35 (expr -> TRUE_KW .)
    SUB_OP          reduce using rule 35 (expr -> TRUE_KW .)
    LT_OP           reduce using rule 35 (expr -> TRUE_KW .)
    LE_OP           reduce using rule 35 (expr -> TRUE_KW .)
    EQ_OP           reduce using rule 35 (expr -> TRUE_KW .)
    NE_OP           reduce using rule 35 (expr -> TRUE_KW .)
    GE_OP           reduce using rule 35 (expr -> TRUE_KW .)
    GT_OP           reduce using rule 35 (expr -> TRUE_KW .)
    DO_KW           reduce using rule 35 (expr -> TRUE_KW .)
    SEMICOLON       reduce using rule 35 (expr -> TRUE_KW .)
    RIGHT_PA        reduce using rule 35 (expr -> TRUE_KW .)
    COMMA           reduce using rule 35 (expr -> TRUE_KW .)
    TO_KW           reduce using rule 35 (expr -> TRUE_KW .)


state 41

    (36) expr -> FALSE_KW .

    THEN_KW         reduce using rule 36 (expr -> FALSE_KW .)
    AND_KW          reduce using rule 36 (expr -> FALSE_KW .)
    OR_KW           reduce using rule 36 (expr -> FALSE_KW .)
    MUL_OP          reduce using rule 36 (expr -> FALSE_KW .)
    DIV_OP          reduce using rule 36 (expr -> FALSE_KW .)
    ADD_OP          reduce using rule 36 (expr -> FALSE_KW .)
    SUB_OP          reduce using rule 36 (expr -> FALSE_KW .)
    LT_OP           reduce using rule 36 (expr -> FALSE_KW .)
    LE_OP           reduce using rule 36 (expr -> FALSE_KW .)
    EQ_OP           reduce using rule 36 (expr -> FALSE_KW .)
    NE_OP           reduce using rule 36 (expr -> FALSE_KW .)
    GE_OP           reduce using rule 36 (expr -> FALSE_KW .)
    GT_OP           reduce using rule 36 (expr -> FALSE_KW .)
    DO_KW           reduce using rule 36 (expr -> FALSE_KW .)
    SEMICOLON       reduce using rule 36 (expr -> FALSE_KW .)
    RIGHT_PA        reduce using rule 36 (expr -> FALSE_KW .)
    COMMA           reduce using rule 36 (expr -> FALSE_KW .)
    TO_KW           reduce using rule 36 (expr -> FALSE_KW .)


state 42

    (37) expr -> IDENTIFIER . LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> IDENTIFIER .

    LEFT_PA         shift and go to state 64
    THEN_KW         reduce using rule 38 (expr -> IDENTIFIER .)
    AND_KW          reduce using rule 38 (expr -> IDENTIFIER .)
    OR_KW           reduce using rule 38 (expr -> IDENTIFIER .)
    MUL_OP          reduce using rule 38 (expr -> IDENTIFIER .)
    DIV_OP          reduce using rule 38 (expr -> IDENTIFIER .)
    ADD_OP          reduce using rule 38 (expr -> IDENTIFIER .)
    SUB_OP          reduce using rule 38 (expr -> IDENTIFIER .)
    LT_OP           reduce using rule 38 (expr -> IDENTIFIER .)
    LE_OP           reduce using rule 38 (expr -> IDENTIFIER .)
    EQ_OP           reduce using rule 38 (expr -> IDENTIFIER .)
    NE_OP           reduce using rule 38 (expr -> IDENTIFIER .)
    GE_OP           reduce using rule 38 (expr -> IDENTIFIER .)
    GT_OP           reduce using rule 38 (expr -> IDENTIFIER .)
    DO_KW           reduce using rule 38 (expr -> IDENTIFIER .)
    SEMICOLON       reduce using rule 38 (expr -> IDENTIFIER .)
    RIGHT_PA        reduce using rule 38 (expr -> IDENTIFIER .)
    COMMA           reduce using rule 38 (expr -> IDENTIFIER .)
    TO_KW           reduce using rule 38 (expr -> IDENTIFIER .)


state 43

    (21) stmt -> WHILE_KW expr . DO_KW stmt
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    DO_KW           shift and go to state 65
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 44

    (22) stmt -> FOR_KW IDENTIFIER . ASSIGN_OP expr TO_KW expr DO_KW stmt

    ASSIGN_OP       shift and go to state 66


state 45

    (23) stmt -> RETURN_KW expr . SEMICOLON
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    SEMICOLON       shift and go to state 67
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 46

    (13) funcDec -> FUNCTION_KW IDENTIFIER parameters . COLON type decList block

    COLON           shift and go to state 68


state 47

    (14) parameters -> LEFT_PA . decList RIGHT_PA
    (2) decList -> . decs
    (3) decList -> . decs decList
    (4) decs -> . type varList SEMICOLON
    (5) decs -> . empty
    (6) type -> . INTEGER_KW
    (7) type -> . REAL_KW
    (8) type -> . BOOLEAN_KW
    (48) empty -> .

  ! shift/reduce conflict for INTEGER_KW resolved as shift
  ! shift/reduce conflict for REAL_KW resolved as shift
  ! shift/reduce conflict for BOOLEAN_KW resolved as shift
    INTEGER_KW      shift and go to state 9
    REAL_KW         shift and go to state 10
    BOOLEAN_KW      shift and go to state 11
    RIGHT_PA        reduce using rule 48 (empty -> .)

  ! INTEGER_KW      [ reduce using rule 48 (empty -> .) ]
  ! REAL_KW         [ reduce using rule 48 (empty -> .) ]
  ! BOOLEAN_KW      [ reduce using rule 48 (empty -> .) ]

    decList                        shift and go to state 69
    decs                           shift and go to state 6
    type                           shift and go to state 7
    empty                          shift and go to state 8

state 48

    (18) stmt -> IDENTIFIER ASSIGN_OP expr . SEMICOLON
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    SEMICOLON       shift and go to state 70
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 49

    (19) stmt -> IF_KW expr THEN_KW . stmt
    (20) stmt -> IF_KW expr THEN_KW . stmt ELSE_KW stmt
    (18) stmt -> . IDENTIFIER ASSIGN_OP expr SEMICOLON
    (19) stmt -> . IF_KW expr THEN_KW stmt
    (20) stmt -> . IF_KW expr THEN_KW stmt ELSE_KW stmt
    (21) stmt -> . WHILE_KW expr DO_KW stmt
    (22) stmt -> . FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt
    (23) stmt -> . RETURN_KW expr SEMICOLON
    (24) stmt -> . block
    (15) block -> . BEGIN_KW stmtList END_KW

    IDENTIFIER      shift and go to state 25
    IF_KW           shift and go to state 26
    WHILE_KW        shift and go to state 27
    FOR_KW          shift and go to state 28
    RETURN_KW       shift and go to state 29
    BEGIN_KW        shift and go to state 19

    stmt                           shift and go to state 71
    block                          shift and go to state 30

state 50

    (25) expr -> expr AND_KW . expr
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 72

state 51

    (26) expr -> expr OR_KW . expr
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 73

state 52

    (27) expr -> expr MUL_OP . expr
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 74

state 53

    (28) expr -> expr DIV_OP . expr
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 75

state 54

    (29) expr -> expr ADD_OP . expr
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 76

state 55

    (30) expr -> expr SUB_OP . expr
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 77

state 56

    (31) expr -> expr relop . expr
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 78

state 57

    (42) relop -> LT_OP .

    LEFT_PA         reduce using rule 42 (relop -> LT_OP .)
    INTEGER_NUMBER  reduce using rule 42 (relop -> LT_OP .)
    REAL_NUMBER     reduce using rule 42 (relop -> LT_OP .)
    TRUE_KW         reduce using rule 42 (relop -> LT_OP .)
    FALSE_KW        reduce using rule 42 (relop -> LT_OP .)
    IDENTIFIER      reduce using rule 42 (relop -> LT_OP .)


state 58

    (43) relop -> LE_OP .

    LEFT_PA         reduce using rule 43 (relop -> LE_OP .)
    INTEGER_NUMBER  reduce using rule 43 (relop -> LE_OP .)
    REAL_NUMBER     reduce using rule 43 (relop -> LE_OP .)
    TRUE_KW         reduce using rule 43 (relop -> LE_OP .)
    FALSE_KW        reduce using rule 43 (relop -> LE_OP .)
    IDENTIFIER      reduce using rule 43 (relop -> LE_OP .)


state 59

    (44) relop -> EQ_OP .

    LEFT_PA         reduce using rule 44 (relop -> EQ_OP .)
    INTEGER_NUMBER  reduce using rule 44 (relop -> EQ_OP .)
    REAL_NUMBER     reduce using rule 44 (relop -> EQ_OP .)
    TRUE_KW         reduce using rule 44 (relop -> EQ_OP .)
    FALSE_KW        reduce using rule 44 (relop -> EQ_OP .)
    IDENTIFIER      reduce using rule 44 (relop -> EQ_OP .)


state 60

    (45) relop -> NE_OP .

    LEFT_PA         reduce using rule 45 (relop -> NE_OP .)
    INTEGER_NUMBER  reduce using rule 45 (relop -> NE_OP .)
    REAL_NUMBER     reduce using rule 45 (relop -> NE_OP .)
    TRUE_KW         reduce using rule 45 (relop -> NE_OP .)
    FALSE_KW        reduce using rule 45 (relop -> NE_OP .)
    IDENTIFIER      reduce using rule 45 (relop -> NE_OP .)


state 61

    (46) relop -> GE_OP .

    LEFT_PA         reduce using rule 46 (relop -> GE_OP .)
    INTEGER_NUMBER  reduce using rule 46 (relop -> GE_OP .)
    REAL_NUMBER     reduce using rule 46 (relop -> GE_OP .)
    TRUE_KW         reduce using rule 46 (relop -> GE_OP .)
    FALSE_KW        reduce using rule 46 (relop -> GE_OP .)
    IDENTIFIER      reduce using rule 46 (relop -> GE_OP .)


state 62

    (47) relop -> GT_OP .

    LEFT_PA         reduce using rule 47 (relop -> GT_OP .)
    INTEGER_NUMBER  reduce using rule 47 (relop -> GT_OP .)
    REAL_NUMBER     reduce using rule 47 (relop -> GT_OP .)
    TRUE_KW         reduce using rule 47 (relop -> GT_OP .)
    FALSE_KW        reduce using rule 47 (relop -> GT_OP .)
    IDENTIFIER      reduce using rule 47 (relop -> GT_OP .)


state 63

    (32) expr -> LEFT_PA expr . RIGHT_PA
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    RIGHT_PA        shift and go to state 79
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 64

    (37) expr -> IDENTIFIER LEFT_PA . actualparamlist RIGHT_PA
    (39) actualparamlist -> . expr
    (40) actualparamlist -> . actualparamlist COMMA expr
    (41) actualparamlist -> . empty
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER
    (48) empty -> .

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42
    RIGHT_PA        reduce using rule 48 (empty -> .)
    COMMA           reduce using rule 48 (empty -> .)

    actualparamlist                shift and go to state 80
    expr                           shift and go to state 81
    empty                          shift and go to state 82

state 65

    (21) stmt -> WHILE_KW expr DO_KW . stmt
    (18) stmt -> . IDENTIFIER ASSIGN_OP expr SEMICOLON
    (19) stmt -> . IF_KW expr THEN_KW stmt
    (20) stmt -> . IF_KW expr THEN_KW stmt ELSE_KW stmt
    (21) stmt -> . WHILE_KW expr DO_KW stmt
    (22) stmt -> . FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt
    (23) stmt -> . RETURN_KW expr SEMICOLON
    (24) stmt -> . block
    (15) block -> . BEGIN_KW stmtList END_KW

    IDENTIFIER      shift and go to state 25
    IF_KW           shift and go to state 26
    WHILE_KW        shift and go to state 27
    FOR_KW          shift and go to state 28
    RETURN_KW       shift and go to state 29
    BEGIN_KW        shift and go to state 19

    stmt                           shift and go to state 83
    block                          shift and go to state 30

state 66

    (22) stmt -> FOR_KW IDENTIFIER ASSIGN_OP . expr TO_KW expr DO_KW stmt
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 84

state 67

    (23) stmt -> RETURN_KW expr SEMICOLON .

    IDENTIFIER      reduce using rule 23 (stmt -> RETURN_KW expr SEMICOLON .)
    IF_KW           reduce using rule 23 (stmt -> RETURN_KW expr SEMICOLON .)
    WHILE_KW        reduce using rule 23 (stmt -> RETURN_KW expr SEMICOLON .)
    FOR_KW          reduce using rule 23 (stmt -> RETURN_KW expr SEMICOLON .)
    RETURN_KW       reduce using rule 23 (stmt -> RETURN_KW expr SEMICOLON .)
    BEGIN_KW        reduce using rule 23 (stmt -> RETURN_KW expr SEMICOLON .)
    END_KW          reduce using rule 23 (stmt -> RETURN_KW expr SEMICOLON .)
    ELSE_KW         reduce using rule 23 (stmt -> RETURN_KW expr SEMICOLON .)


state 68

    (13) funcDec -> FUNCTION_KW IDENTIFIER parameters COLON . type decList block
    (6) type -> . INTEGER_KW
    (7) type -> . REAL_KW
    (8) type -> . BOOLEAN_KW

    INTEGER_KW      shift and go to state 9
    REAL_KW         shift and go to state 10
    BOOLEAN_KW      shift and go to state 11

    type                           shift and go to state 85

state 69

    (14) parameters -> LEFT_PA decList . RIGHT_PA

    RIGHT_PA        shift and go to state 86


state 70

    (18) stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .

    IDENTIFIER      reduce using rule 18 (stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .)
    IF_KW           reduce using rule 18 (stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .)
    WHILE_KW        reduce using rule 18 (stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .)
    FOR_KW          reduce using rule 18 (stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .)
    RETURN_KW       reduce using rule 18 (stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .)
    BEGIN_KW        reduce using rule 18 (stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .)
    END_KW          reduce using rule 18 (stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .)
    ELSE_KW         reduce using rule 18 (stmt -> IDENTIFIER ASSIGN_OP expr SEMICOLON .)


state 71

    (19) stmt -> IF_KW expr THEN_KW stmt .
    (20) stmt -> IF_KW expr THEN_KW stmt . ELSE_KW stmt

  ! shift/reduce conflict for ELSE_KW resolved as shift
    IDENTIFIER      reduce using rule 19 (stmt -> IF_KW expr THEN_KW stmt .)
    IF_KW           reduce using rule 19 (stmt -> IF_KW expr THEN_KW stmt .)
    WHILE_KW        reduce using rule 19 (stmt -> IF_KW expr THEN_KW stmt .)
    FOR_KW          reduce using rule 19 (stmt -> IF_KW expr THEN_KW stmt .)
    RETURN_KW       reduce using rule 19 (stmt -> IF_KW expr THEN_KW stmt .)
    BEGIN_KW        reduce using rule 19 (stmt -> IF_KW expr THEN_KW stmt .)
    END_KW          reduce using rule 19 (stmt -> IF_KW expr THEN_KW stmt .)
    ELSE_KW         shift and go to state 87

  ! ELSE_KW         [ reduce using rule 19 (stmt -> IF_KW expr THEN_KW stmt .) ]


state 72

    (25) expr -> expr AND_KW expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    THEN_KW         reduce using rule 25 (expr -> expr AND_KW expr .)
    AND_KW          reduce using rule 25 (expr -> expr AND_KW expr .)
    OR_KW           reduce using rule 25 (expr -> expr AND_KW expr .)
    LT_OP           reduce using rule 25 (expr -> expr AND_KW expr .)
    LE_OP           reduce using rule 25 (expr -> expr AND_KW expr .)
    EQ_OP           reduce using rule 25 (expr -> expr AND_KW expr .)
    NE_OP           reduce using rule 25 (expr -> expr AND_KW expr .)
    GE_OP           reduce using rule 25 (expr -> expr AND_KW expr .)
    GT_OP           reduce using rule 25 (expr -> expr AND_KW expr .)
    DO_KW           reduce using rule 25 (expr -> expr AND_KW expr .)
    SEMICOLON       reduce using rule 25 (expr -> expr AND_KW expr .)
    RIGHT_PA        reduce using rule 25 (expr -> expr AND_KW expr .)
    COMMA           reduce using rule 25 (expr -> expr AND_KW expr .)
    TO_KW           reduce using rule 25 (expr -> expr AND_KW expr .)
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55

  ! MUL_OP          [ reduce using rule 25 (expr -> expr AND_KW expr .) ]
  ! DIV_OP          [ reduce using rule 25 (expr -> expr AND_KW expr .) ]
  ! ADD_OP          [ reduce using rule 25 (expr -> expr AND_KW expr .) ]
  ! SUB_OP          [ reduce using rule 25 (expr -> expr AND_KW expr .) ]
  ! AND_KW          [ shift and go to state 50 ]
  ! OR_KW           [ shift and go to state 51 ]
  ! LT_OP           [ shift and go to state 57 ]
  ! LE_OP           [ shift and go to state 58 ]
  ! EQ_OP           [ shift and go to state 59 ]
  ! NE_OP           [ shift and go to state 60 ]
  ! GE_OP           [ shift and go to state 61 ]
  ! GT_OP           [ shift and go to state 62 ]

    relop                          shift and go to state 56

state 73

    (26) expr -> expr OR_KW expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    THEN_KW         reduce using rule 26 (expr -> expr OR_KW expr .)
    OR_KW           reduce using rule 26 (expr -> expr OR_KW expr .)
    LT_OP           reduce using rule 26 (expr -> expr OR_KW expr .)
    LE_OP           reduce using rule 26 (expr -> expr OR_KW expr .)
    EQ_OP           reduce using rule 26 (expr -> expr OR_KW expr .)
    NE_OP           reduce using rule 26 (expr -> expr OR_KW expr .)
    GE_OP           reduce using rule 26 (expr -> expr OR_KW expr .)
    GT_OP           reduce using rule 26 (expr -> expr OR_KW expr .)
    DO_KW           reduce using rule 26 (expr -> expr OR_KW expr .)
    SEMICOLON       reduce using rule 26 (expr -> expr OR_KW expr .)
    RIGHT_PA        reduce using rule 26 (expr -> expr OR_KW expr .)
    COMMA           reduce using rule 26 (expr -> expr OR_KW expr .)
    TO_KW           reduce using rule 26 (expr -> expr OR_KW expr .)
    AND_KW          shift and go to state 50
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55

  ! AND_KW          [ reduce using rule 26 (expr -> expr OR_KW expr .) ]
  ! MUL_OP          [ reduce using rule 26 (expr -> expr OR_KW expr .) ]
  ! DIV_OP          [ reduce using rule 26 (expr -> expr OR_KW expr .) ]
  ! ADD_OP          [ reduce using rule 26 (expr -> expr OR_KW expr .) ]
  ! SUB_OP          [ reduce using rule 26 (expr -> expr OR_KW expr .) ]
  ! OR_KW           [ shift and go to state 51 ]
  ! LT_OP           [ shift and go to state 57 ]
  ! LE_OP           [ shift and go to state 58 ]
  ! EQ_OP           [ shift and go to state 59 ]
  ! NE_OP           [ shift and go to state 60 ]
  ! GE_OP           [ shift and go to state 61 ]
  ! GT_OP           [ shift and go to state 62 ]

    relop                          shift and go to state 56

state 74

    (27) expr -> expr MUL_OP expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    THEN_KW         reduce using rule 27 (expr -> expr MUL_OP expr .)
    AND_KW          reduce using rule 27 (expr -> expr MUL_OP expr .)
    OR_KW           reduce using rule 27 (expr -> expr MUL_OP expr .)
    MUL_OP          reduce using rule 27 (expr -> expr MUL_OP expr .)
    DIV_OP          reduce using rule 27 (expr -> expr MUL_OP expr .)
    ADD_OP          reduce using rule 27 (expr -> expr MUL_OP expr .)
    SUB_OP          reduce using rule 27 (expr -> expr MUL_OP expr .)
    LT_OP           reduce using rule 27 (expr -> expr MUL_OP expr .)
    LE_OP           reduce using rule 27 (expr -> expr MUL_OP expr .)
    EQ_OP           reduce using rule 27 (expr -> expr MUL_OP expr .)
    NE_OP           reduce using rule 27 (expr -> expr MUL_OP expr .)
    GE_OP           reduce using rule 27 (expr -> expr MUL_OP expr .)
    GT_OP           reduce using rule 27 (expr -> expr MUL_OP expr .)
    DO_KW           reduce using rule 27 (expr -> expr MUL_OP expr .)
    SEMICOLON       reduce using rule 27 (expr -> expr MUL_OP expr .)
    RIGHT_PA        reduce using rule 27 (expr -> expr MUL_OP expr .)
    COMMA           reduce using rule 27 (expr -> expr MUL_OP expr .)
    TO_KW           reduce using rule 27 (expr -> expr MUL_OP expr .)

  ! AND_KW          [ shift and go to state 50 ]
  ! OR_KW           [ shift and go to state 51 ]
  ! MUL_OP          [ shift and go to state 52 ]
  ! DIV_OP          [ shift and go to state 53 ]
  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 55 ]
  ! LT_OP           [ shift and go to state 57 ]
  ! LE_OP           [ shift and go to state 58 ]
  ! EQ_OP           [ shift and go to state 59 ]
  ! NE_OP           [ shift and go to state 60 ]
  ! GE_OP           [ shift and go to state 61 ]
  ! GT_OP           [ shift and go to state 62 ]

    relop                          shift and go to state 56

state 75

    (28) expr -> expr DIV_OP expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    THEN_KW         reduce using rule 28 (expr -> expr DIV_OP expr .)
    AND_KW          reduce using rule 28 (expr -> expr DIV_OP expr .)
    OR_KW           reduce using rule 28 (expr -> expr DIV_OP expr .)
    MUL_OP          reduce using rule 28 (expr -> expr DIV_OP expr .)
    DIV_OP          reduce using rule 28 (expr -> expr DIV_OP expr .)
    ADD_OP          reduce using rule 28 (expr -> expr DIV_OP expr .)
    SUB_OP          reduce using rule 28 (expr -> expr DIV_OP expr .)
    LT_OP           reduce using rule 28 (expr -> expr DIV_OP expr .)
    LE_OP           reduce using rule 28 (expr -> expr DIV_OP expr .)
    EQ_OP           reduce using rule 28 (expr -> expr DIV_OP expr .)
    NE_OP           reduce using rule 28 (expr -> expr DIV_OP expr .)
    GE_OP           reduce using rule 28 (expr -> expr DIV_OP expr .)
    GT_OP           reduce using rule 28 (expr -> expr DIV_OP expr .)
    DO_KW           reduce using rule 28 (expr -> expr DIV_OP expr .)
    SEMICOLON       reduce using rule 28 (expr -> expr DIV_OP expr .)
    RIGHT_PA        reduce using rule 28 (expr -> expr DIV_OP expr .)
    COMMA           reduce using rule 28 (expr -> expr DIV_OP expr .)
    TO_KW           reduce using rule 28 (expr -> expr DIV_OP expr .)

  ! AND_KW          [ shift and go to state 50 ]
  ! OR_KW           [ shift and go to state 51 ]
  ! MUL_OP          [ shift and go to state 52 ]
  ! DIV_OP          [ shift and go to state 53 ]
  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 55 ]
  ! LT_OP           [ shift and go to state 57 ]
  ! LE_OP           [ shift and go to state 58 ]
  ! EQ_OP           [ shift and go to state 59 ]
  ! NE_OP           [ shift and go to state 60 ]
  ! GE_OP           [ shift and go to state 61 ]
  ! GT_OP           [ shift and go to state 62 ]

    relop                          shift and go to state 56

state 76

    (29) expr -> expr ADD_OP expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    THEN_KW         reduce using rule 29 (expr -> expr ADD_OP expr .)
    AND_KW          reduce using rule 29 (expr -> expr ADD_OP expr .)
    OR_KW           reduce using rule 29 (expr -> expr ADD_OP expr .)
    ADD_OP          reduce using rule 29 (expr -> expr ADD_OP expr .)
    SUB_OP          reduce using rule 29 (expr -> expr ADD_OP expr .)
    LT_OP           reduce using rule 29 (expr -> expr ADD_OP expr .)
    LE_OP           reduce using rule 29 (expr -> expr ADD_OP expr .)
    EQ_OP           reduce using rule 29 (expr -> expr ADD_OP expr .)
    NE_OP           reduce using rule 29 (expr -> expr ADD_OP expr .)
    GE_OP           reduce using rule 29 (expr -> expr ADD_OP expr .)
    GT_OP           reduce using rule 29 (expr -> expr ADD_OP expr .)
    DO_KW           reduce using rule 29 (expr -> expr ADD_OP expr .)
    SEMICOLON       reduce using rule 29 (expr -> expr ADD_OP expr .)
    RIGHT_PA        reduce using rule 29 (expr -> expr ADD_OP expr .)
    COMMA           reduce using rule 29 (expr -> expr ADD_OP expr .)
    TO_KW           reduce using rule 29 (expr -> expr ADD_OP expr .)
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53

  ! MUL_OP          [ reduce using rule 29 (expr -> expr ADD_OP expr .) ]
  ! DIV_OP          [ reduce using rule 29 (expr -> expr ADD_OP expr .) ]
  ! AND_KW          [ shift and go to state 50 ]
  ! OR_KW           [ shift and go to state 51 ]
  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 55 ]
  ! LT_OP           [ shift and go to state 57 ]
  ! LE_OP           [ shift and go to state 58 ]
  ! EQ_OP           [ shift and go to state 59 ]
  ! NE_OP           [ shift and go to state 60 ]
  ! GE_OP           [ shift and go to state 61 ]
  ! GT_OP           [ shift and go to state 62 ]

    relop                          shift and go to state 56

state 77

    (30) expr -> expr SUB_OP expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    THEN_KW         reduce using rule 30 (expr -> expr SUB_OP expr .)
    AND_KW          reduce using rule 30 (expr -> expr SUB_OP expr .)
    OR_KW           reduce using rule 30 (expr -> expr SUB_OP expr .)
    ADD_OP          reduce using rule 30 (expr -> expr SUB_OP expr .)
    SUB_OP          reduce using rule 30 (expr -> expr SUB_OP expr .)
    LT_OP           reduce using rule 30 (expr -> expr SUB_OP expr .)
    LE_OP           reduce using rule 30 (expr -> expr SUB_OP expr .)
    EQ_OP           reduce using rule 30 (expr -> expr SUB_OP expr .)
    NE_OP           reduce using rule 30 (expr -> expr SUB_OP expr .)
    GE_OP           reduce using rule 30 (expr -> expr SUB_OP expr .)
    GT_OP           reduce using rule 30 (expr -> expr SUB_OP expr .)
    DO_KW           reduce using rule 30 (expr -> expr SUB_OP expr .)
    SEMICOLON       reduce using rule 30 (expr -> expr SUB_OP expr .)
    RIGHT_PA        reduce using rule 30 (expr -> expr SUB_OP expr .)
    COMMA           reduce using rule 30 (expr -> expr SUB_OP expr .)
    TO_KW           reduce using rule 30 (expr -> expr SUB_OP expr .)
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53

  ! MUL_OP          [ reduce using rule 30 (expr -> expr SUB_OP expr .) ]
  ! DIV_OP          [ reduce using rule 30 (expr -> expr SUB_OP expr .) ]
  ! AND_KW          [ shift and go to state 50 ]
  ! OR_KW           [ shift and go to state 51 ]
  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 55 ]
  ! LT_OP           [ shift and go to state 57 ]
  ! LE_OP           [ shift and go to state 58 ]
  ! EQ_OP           [ shift and go to state 59 ]
  ! NE_OP           [ shift and go to state 60 ]
  ! GE_OP           [ shift and go to state 61 ]
  ! GT_OP           [ shift and go to state 62 ]

    relop                          shift and go to state 56

state 78

    (31) expr -> expr relop expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

  ! shift/reduce conflict for AND_KW resolved as shift
  ! shift/reduce conflict for OR_KW resolved as shift
  ! shift/reduce conflict for MUL_OP resolved as shift
  ! shift/reduce conflict for DIV_OP resolved as shift
  ! shift/reduce conflict for ADD_OP resolved as shift
  ! shift/reduce conflict for SUB_OP resolved as shift
  ! shift/reduce conflict for LT_OP resolved as shift
  ! shift/reduce conflict for LE_OP resolved as shift
  ! shift/reduce conflict for EQ_OP resolved as shift
  ! shift/reduce conflict for NE_OP resolved as shift
  ! shift/reduce conflict for GE_OP resolved as shift
  ! shift/reduce conflict for GT_OP resolved as shift
    THEN_KW         reduce using rule 31 (expr -> expr relop expr .)
    DO_KW           reduce using rule 31 (expr -> expr relop expr .)
    SEMICOLON       reduce using rule 31 (expr -> expr relop expr .)
    RIGHT_PA        reduce using rule 31 (expr -> expr relop expr .)
    COMMA           reduce using rule 31 (expr -> expr relop expr .)
    TO_KW           reduce using rule 31 (expr -> expr relop expr .)
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

  ! AND_KW          [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! OR_KW           [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! MUL_OP          [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! DIV_OP          [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! ADD_OP          [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! SUB_OP          [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! LT_OP           [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! LE_OP           [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! EQ_OP           [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! NE_OP           [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! GE_OP           [ reduce using rule 31 (expr -> expr relop expr .) ]
  ! GT_OP           [ reduce using rule 31 (expr -> expr relop expr .) ]

    relop                          shift and go to state 56

state 79

    (32) expr -> LEFT_PA expr RIGHT_PA .

    THEN_KW         reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    AND_KW          reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    OR_KW           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    MUL_OP          reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    DIV_OP          reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    ADD_OP          reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    SUB_OP          reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    LT_OP           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    LE_OP           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    EQ_OP           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    NE_OP           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    GE_OP           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    GT_OP           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    DO_KW           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    SEMICOLON       reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    RIGHT_PA        reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    COMMA           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)
    TO_KW           reduce using rule 32 (expr -> LEFT_PA expr RIGHT_PA .)


state 80

    (37) expr -> IDENTIFIER LEFT_PA actualparamlist . RIGHT_PA
    (40) actualparamlist -> actualparamlist . COMMA expr

    RIGHT_PA        shift and go to state 88
    COMMA           shift and go to state 89


state 81

    (39) actualparamlist -> expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    RIGHT_PA        reduce using rule 39 (actualparamlist -> expr .)
    COMMA           reduce using rule 39 (actualparamlist -> expr .)
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 82

    (41) actualparamlist -> empty .

    RIGHT_PA        reduce using rule 41 (actualparamlist -> empty .)
    COMMA           reduce using rule 41 (actualparamlist -> empty .)


state 83

    (21) stmt -> WHILE_KW expr DO_KW stmt .

    IDENTIFIER      reduce using rule 21 (stmt -> WHILE_KW expr DO_KW stmt .)
    IF_KW           reduce using rule 21 (stmt -> WHILE_KW expr DO_KW stmt .)
    WHILE_KW        reduce using rule 21 (stmt -> WHILE_KW expr DO_KW stmt .)
    FOR_KW          reduce using rule 21 (stmt -> WHILE_KW expr DO_KW stmt .)
    RETURN_KW       reduce using rule 21 (stmt -> WHILE_KW expr DO_KW stmt .)
    BEGIN_KW        reduce using rule 21 (stmt -> WHILE_KW expr DO_KW stmt .)
    END_KW          reduce using rule 21 (stmt -> WHILE_KW expr DO_KW stmt .)
    ELSE_KW         reduce using rule 21 (stmt -> WHILE_KW expr DO_KW stmt .)


state 84

    (22) stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr . TO_KW expr DO_KW stmt
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    TO_KW           shift and go to state 90
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 85

    (13) funcDec -> FUNCTION_KW IDENTIFIER parameters COLON type . decList block
    (2) decList -> . decs
    (3) decList -> . decs decList
    (4) decs -> . type varList SEMICOLON
    (5) decs -> . empty
    (6) type -> . INTEGER_KW
    (7) type -> . REAL_KW
    (8) type -> . BOOLEAN_KW
    (48) empty -> .

  ! shift/reduce conflict for INTEGER_KW resolved as shift
  ! shift/reduce conflict for REAL_KW resolved as shift
  ! shift/reduce conflict for BOOLEAN_KW resolved as shift
    INTEGER_KW      shift and go to state 9
    REAL_KW         shift and go to state 10
    BOOLEAN_KW      shift and go to state 11
    BEGIN_KW        reduce using rule 48 (empty -> .)

  ! INTEGER_KW      [ reduce using rule 48 (empty -> .) ]
  ! REAL_KW         [ reduce using rule 48 (empty -> .) ]
  ! BOOLEAN_KW      [ reduce using rule 48 (empty -> .) ]

    type                           shift and go to state 7
    decList                        shift and go to state 91
    decs                           shift and go to state 6
    empty                          shift and go to state 8

state 86

    (14) parameters -> LEFT_PA decList RIGHT_PA .

    COLON           reduce using rule 14 (parameters -> LEFT_PA decList RIGHT_PA .)


state 87

    (20) stmt -> IF_KW expr THEN_KW stmt ELSE_KW . stmt
    (18) stmt -> . IDENTIFIER ASSIGN_OP expr SEMICOLON
    (19) stmt -> . IF_KW expr THEN_KW stmt
    (20) stmt -> . IF_KW expr THEN_KW stmt ELSE_KW stmt
    (21) stmt -> . WHILE_KW expr DO_KW stmt
    (22) stmt -> . FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt
    (23) stmt -> . RETURN_KW expr SEMICOLON
    (24) stmt -> . block
    (15) block -> . BEGIN_KW stmtList END_KW

    IDENTIFIER      shift and go to state 25
    IF_KW           shift and go to state 26
    WHILE_KW        shift and go to state 27
    FOR_KW          shift and go to state 28
    RETURN_KW       shift and go to state 29
    BEGIN_KW        shift and go to state 19

    stmt                           shift and go to state 92
    block                          shift and go to state 30

state 88

    (37) expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .

    THEN_KW         reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    AND_KW          reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    OR_KW           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    MUL_OP          reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    DIV_OP          reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    ADD_OP          reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    SUB_OP          reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    LT_OP           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    LE_OP           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    EQ_OP           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    NE_OP           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    GE_OP           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    GT_OP           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    DO_KW           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    SEMICOLON       reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    RIGHT_PA        reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    COMMA           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)
    TO_KW           reduce using rule 37 (expr -> IDENTIFIER LEFT_PA actualparamlist RIGHT_PA .)


state 89

    (40) actualparamlist -> actualparamlist COMMA . expr
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 93

state 90

    (22) stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW . expr DO_KW stmt
    (25) expr -> . expr AND_KW expr
    (26) expr -> . expr OR_KW expr
    (27) expr -> . expr MUL_OP expr
    (28) expr -> . expr DIV_OP expr
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr relop expr
    (32) expr -> . LEFT_PA expr RIGHT_PA
    (33) expr -> . INTEGER_NUMBER
    (34) expr -> . REAL_NUMBER
    (35) expr -> . TRUE_KW
    (36) expr -> . FALSE_KW
    (37) expr -> . IDENTIFIER LEFT_PA actualparamlist RIGHT_PA
    (38) expr -> . IDENTIFIER

    LEFT_PA         shift and go to state 37
    INTEGER_NUMBER  shift and go to state 38
    REAL_NUMBER     shift and go to state 39
    TRUE_KW         shift and go to state 40
    FALSE_KW        shift and go to state 41
    IDENTIFIER      shift and go to state 42

    expr                           shift and go to state 94

state 91

    (13) funcDec -> FUNCTION_KW IDENTIFIER parameters COLON type decList . block
    (15) block -> . BEGIN_KW stmtList END_KW

    BEGIN_KW        shift and go to state 19

    block                          shift and go to state 95

state 92

    (20) stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .

    IDENTIFIER      reduce using rule 20 (stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .)
    IF_KW           reduce using rule 20 (stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .)
    WHILE_KW        reduce using rule 20 (stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .)
    FOR_KW          reduce using rule 20 (stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .)
    RETURN_KW       reduce using rule 20 (stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .)
    BEGIN_KW        reduce using rule 20 (stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .)
    END_KW          reduce using rule 20 (stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .)
    ELSE_KW         reduce using rule 20 (stmt -> IF_KW expr THEN_KW stmt ELSE_KW stmt .)


state 93

    (40) actualparamlist -> actualparamlist COMMA expr .
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    RIGHT_PA        reduce using rule 40 (actualparamlist -> actualparamlist COMMA expr .)
    COMMA           reduce using rule 40 (actualparamlist -> actualparamlist COMMA expr .)
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 94

    (22) stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr . DO_KW stmt
    (25) expr -> expr . AND_KW expr
    (26) expr -> expr . OR_KW expr
    (27) expr -> expr . MUL_OP expr
    (28) expr -> expr . DIV_OP expr
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . relop expr
    (42) relop -> . LT_OP
    (43) relop -> . LE_OP
    (44) relop -> . EQ_OP
    (45) relop -> . NE_OP
    (46) relop -> . GE_OP
    (47) relop -> . GT_OP

    DO_KW           shift and go to state 96
    AND_KW          shift and go to state 50
    OR_KW           shift and go to state 51
    MUL_OP          shift and go to state 52
    DIV_OP          shift and go to state 53
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 55
    LT_OP           shift and go to state 57
    LE_OP           shift and go to state 58
    EQ_OP           shift and go to state 59
    NE_OP           shift and go to state 60
    GE_OP           shift and go to state 61
    GT_OP           shift and go to state 62

    relop                          shift and go to state 56

state 95

    (13) funcDec -> FUNCTION_KW IDENTIFIER parameters COLON type decList block .

    BEGIN_KW        reduce using rule 13 (funcDec -> FUNCTION_KW IDENTIFIER parameters COLON type decList block .)
    FUNCTION_KW     reduce using rule 13 (funcDec -> FUNCTION_KW IDENTIFIER parameters COLON type decList block .)


state 96

    (22) stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW . stmt
    (18) stmt -> . IDENTIFIER ASSIGN_OP expr SEMICOLON
    (19) stmt -> . IF_KW expr THEN_KW stmt
    (20) stmt -> . IF_KW expr THEN_KW stmt ELSE_KW stmt
    (21) stmt -> . WHILE_KW expr DO_KW stmt
    (22) stmt -> . FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt
    (23) stmt -> . RETURN_KW expr SEMICOLON
    (24) stmt -> . block
    (15) block -> . BEGIN_KW stmtList END_KW

    IDENTIFIER      shift and go to state 25
    IF_KW           shift and go to state 26
    WHILE_KW        shift and go to state 27
    FOR_KW          shift and go to state 28
    RETURN_KW       shift and go to state 29
    BEGIN_KW        shift and go to state 19

    stmt                           shift and go to state 97
    block                          shift and go to state 30

state 97

    (22) stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .

    IDENTIFIER      reduce using rule 22 (stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .)
    IF_KW           reduce using rule 22 (stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .)
    WHILE_KW        reduce using rule 22 (stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .)
    FOR_KW          reduce using rule 22 (stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .)
    RETURN_KW       reduce using rule 22 (stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .)
    BEGIN_KW        reduce using rule 22 (stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .)
    END_KW          reduce using rule 22 (stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .)
    ELSE_KW         reduce using rule 22 (stmt -> FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INTEGER_KW in state 4 resolved as shift
WARNING: shift/reduce conflict for REAL_KW in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_KW in state 4 resolved as shift
WARNING: shift/reduce conflict for INTEGER_KW in state 6 resolved as shift
WARNING: shift/reduce conflict for REAL_KW in state 6 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_KW in state 6 resolved as shift
WARNING: shift/reduce conflict for INTEGER_KW in state 47 resolved as shift
WARNING: shift/reduce conflict for REAL_KW in state 47 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_KW in state 47 resolved as shift
WARNING: shift/reduce conflict for ELSE_KW in state 71 resolved as shift
WARNING: shift/reduce conflict for AND_KW in state 78 resolved as shift
WARNING: shift/reduce conflict for OR_KW in state 78 resolved as shift
WARNING: shift/reduce conflict for MUL_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for DIV_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for ADD_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for SUB_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for LT_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for LE_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for EQ_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for NE_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for GE_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for GT_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for INTEGER_KW in state 85 resolved as shift
WARNING: shift/reduce conflict for REAL_KW in state 85 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_KW in state 85 resolved as shift
WARNING: reduce/reduce conflict in state 6 resolved using rule (decList -> decs)
WARNING: rejected rule (empty -> <empty>) in state 6
