# Phase 2 - Parser

This project is a **Parser** developed for the **Compiler course** at **Khajeh Nasir University of Technology**, designed by **Professor Morteza Damanafshan**. It is the second phase of a Bachelor-level project to construct a compiler. Building on the **Lexical Analyzer** implemented in Phase 1, this phase involves creating a **Parser** to process tokens generated by the lexer and apply syntax rules from the grammar \( G \).

---

## Project Overview

The main goal of this phase is to build a parser for the grammar \( G \), provided as a part of the project description. The parser analyzes the structure of a program by applying production rules defined for the grammar. It detects syntax errors and generates a list of the applied production rules in a readable format.

### Grammar \( G \)

The lexical analyzer supports the following grammar \( G \):

```plaintext
start → program id ; decList funcList block

decList → decs | decList decs
decs → type varList ; | ϵ
type → integer | real | boolean
varList → id | varList , id

funcList → funcList funcDec | ϵ
funcDec → function id parameters : type decList block
parameters → (decList)

block → begin stmtList end
stmtList → stmt | stmtList stmt
stmt → id := expr ;
     | if expr then stmt
     | if expr then stmt else stmt
     | while expr do stmt
     | for id:=expr to expr do stmt
     | return expr ;
     | block

expr → expr and expr | expr or expr
     | expr ∗ expr | expr / expr
     | expr + expr | expr − expr
     | expr relop expr
     | (expr)
     | integerNumber | realNumber
     | true | false
     | id(actualparamlist)
     | id

actualparamlist → expr | actualparamlist, expr | id | ϵ
relop → < | <= | = | <> | >= | >
```

### Key Features

1. **Grammar Parsing**:
   - Implements the grammar \( G \).
   - Handles valid and invalid programs with appropriate error reporting.

2. **Integration with Lexer**:
   - Utilizes the `lexer.py` file from Phase 1 to tokenize the input before parsing.

3. **Output**:
   - Writes the applied production rules and their numbers to `output.txt`.

4. **Examples**:
   - Includes example input programs in the `examples/` directory with corresponding outputs for testing.

5. **PLY Integration**:
   - Uses PLY (Python Lex-Yacc) for defining grammar rules and building the parser.

---

## System Requirements

- **Python 3.8 or higher**
- **PLY (Python Lex-Yacc)** library  
  Install via pip:

  ```bash
  pip install ply
  ```

---

## Project Structure

- **`lexer.py`**: Lexical analyzer implemented in Phase 1.
- **`parser.py`**: Implements the grammar \( G \) and defines the parser using PLY.
- **`main.py`**: Entry point for the program. Reads input, parses it, and writes the results to `output.txt`.
- **`output.txt`**: Contains the list of production rules applied during parsing.
- **`examples/`**: Directory containing example inputs and their expected outputs.
- **`KNTU-Compiler-Project-Fall-1403--Phase2.pdf`**: Project description and grammar details for Phase 2.
- **`parser.out`**: File generated by PLY for debugging the parser.
- **`parsertab.py`**: File generated by PLY for optimizing the parsing process.

---

## Usage

Follow these steps to use the parser:

1. **Prepare the Input File**:
   - Place your program source code in a file named `input.txt` in the project root.

2. **Run the Parser**:
   - Execute the `main.py` file:

     ```bash
     python main.py
     ```

3. **Check the Output**:
   - The results, including the production rules applied during parsing, will be saved to `output.txt`.

4. **Testing with Examples**:
   - Use the provided examples in the `examples/` directory for testing. Compare the generated output with the expected output files.

---

## Output Format

The output file (`output.txt`) contains:

1. **Header**: Displays the author's name, surname, and student ID in both English and Persian.
2. **Production Rules**: Lists each rule applied during parsing in the format:

   ```plaintext
   Rule Number          Production Rule
   ```

### Example 1

**Input** (`input1.txt`):

```plaintext
program testProgram ;
begin
  x := 5 ;
end
```

**Output** (`output1.txt`):

```plaintext
Mohammad Taha Karbalaee Esmaeili - 40121803          محمد طاها کربلای اسمعیلی - ۴۰۱۲۱۸۰۳
5         decs -> ε
2         decList -> decs
12        funcList -> ε
33        expr -> integerNumber
18        stmt -> id := expr ;
16        stmtList -> stmt
15        block -> begin stmtList end
1         start -> program id ; decList funcList block

```

### Example 2

**Input** (`input2.txt`):

```plaintext
program prg1;
integer num, divisor, quotient;
begin
    num:=61;
    divisor:=2;
    quotient:=0;
    if num=1 then
        return false;
    else if num=2 then
        return true;
    while divisor<=(num/2) do
    begin
        quotient:=num/divisor;
        if divisor * quotient=num then
            return false;
        divisor:=divisor+1;
    end
    return true;
end
```

**Output** (`output2.txt`):

```plaintext
Mohammad Taha Karbalaee Esmaeili - 40121803          محمد طاها کربلای اسمعیلی - ۴۰۱۲۱۸۰۳
6         type -> integer
9         varList -> id
10        varList -> varList, id
10        varList -> varList, id
4         decs -> type varList ;
2         decList -> decs
12        funcList -> ε
33        expr -> integerNumber
18        stmt -> id := expr ;
16        stmtList -> stmt
33        expr -> integerNumber
18        stmt -> id := expr ;
17        stmtList -> stmtList stmt
33        expr -> integerNumber
18        stmt -> id := expr ;
17        stmtList -> stmtList stmt
38        expr -> id
45        relop -> =
33        expr -> integerNumber
31        expr -> expr relop expr
36        expr -> false
23        stmt -> return expr ;
38        expr -> id
45        relop -> =
33        expr -> integerNumber
31        expr -> expr relop expr
35        expr -> true
23        stmt -> return expr ;
19        stmt -> if expr then stmt
20        stmt -> if expr then stmt else stmt
17        stmtList -> stmtList stmt
38        expr -> id
44        relop -> <=
38        expr -> id
33        expr -> integerNumber
28        expr -> expr / expr
32        expr -> ( expr )
31        expr -> expr relop expr
38        expr -> id
38        expr -> id
28        expr -> expr / expr
18        stmt -> id := expr ;
16        stmtList -> stmt
38        expr -> id
38        expr -> id
45        relop -> =
38        expr -> id
31        expr -> expr relop expr
27        expr -> expr * expr
36        expr -> false
23        stmt -> return expr ;
19        stmt -> if expr then stmt
17        stmtList -> stmtList stmt
38        expr -> id
33        expr -> integerNumber
29        expr -> expr + expr
18        stmt -> id := expr ;
17        stmtList -> stmtList stmt
15        block -> begin stmtList end
24        stmt -> block
21        stmt -> while expr do stmt
17        stmtList -> stmtList stmt
35        expr -> true
23        stmt -> return expr ;
17        stmtList -> stmtList stmt
15        block -> begin stmtList end
1         start -> program id ; decList funcList block

```

### Example 3

**Input** (`input3.txt`):

```plaintext
program prg2;

function avg(integer m; integer n;):real
integer sum, num;
real average;
begin
    sum:=0;
    average:=0;
    for num:=m to n do
        sum:=sum+num;
    average:=sum/(n-m+1);
    return average;
end

begin
    a:=avg(1,20);
end
```

**Output** (`output3.txt`):

```plaintext
Mohammad Taha Karbalaee Esmaeili - 40121803          محمد طاها کربلای اسمعیلی - ۴۰۱۲۱۸۰۳
5         decs -> ε
2         decList -> decs
12        funcList -> ε
6         type -> integer
9         varList -> id
4         decs -> type varList ;
6         type -> integer
9         varList -> id
4         decs -> type varList ;
2         decList -> decs
3         decList -> decs decList
14        parameters -> ( decList )
7         type -> real
6         type -> integer
9         varList -> id
10        varList -> varList, id
4         decs -> type varList ;
7         type -> real
9         varList -> id
4         decs -> type varList ;
2         decList -> decs
3         decList -> decs decList
33        expr -> integerNumber
18        stmt -> id := expr ;
16        stmtList -> stmt
33        expr -> integerNumber
18        stmt -> id := expr ;
17        stmtList -> stmtList stmt
38        expr -> id
38        expr -> id
38        expr -> id
38        expr -> id
29        expr -> expr + expr
18        stmt -> id := expr ;
22        stmt -> for id := expr to expr do stmt
17        stmtList -> stmtList stmt
38        expr -> id
38        expr -> id
38        expr -> id
30        expr -> expr - expr
33        expr -> integerNumber
29        expr -> expr + expr
32        expr -> ( expr )
28        expr -> expr / expr
18        stmt -> id := expr ;
17        stmtList -> stmtList stmt
38        expr -> id
23        stmt -> return expr ;
17        stmtList -> stmtList stmt
15        block -> begin stmtList end
13        funcDec -> function id parameters : type decList block
11        funcList -> funcList funcDec
33        expr -> integerNumber
39        actualparamlist -> expr
33        expr -> integerNumber
40        actualparamlist -> actualparamlist, expr
37        expr -> id ( actualparamlist )
18        stmt -> id := expr ;
16        stmtList -> stmt
15        block -> begin stmtList end
1         start -> program id ; decList funcList block

```

---

## Notes

- The parser strictly follows the grammar \( G \) provided in the project description.
- Syntax errors are reported during parsing and do not halt the process.
- The `parser.out` and `parsertab.py` files are automatically generated by PLY and should not be manually modified.

---

## Author Information

- **Author**: Mohammad Taha Karbalaee Esmaeili
- **Student ID**: 40121803
- **Acknowledgment**: Designed by **Professor Morteza Damanafshan** for the Compiler course at **Khajeh Nasir University of Technology**.
