import ply.yacc as yacc
from lexer import Lexer

class Parser:
    """
    A parser implementation using PLY (Python Lex-Yacc) for grammar G.
    This parser processes tokens generated by the Lexer class, verifies the 
    input program against the grammar rules, and constructs an abstract syntax 
    tree (AST) representation for further processing (e.g., TAC generation).
    """

    tokens = Lexer.tokens

    precedence = (
        ('left', 'OR_KW'),
        ('left', 'AND_KW'),
        ('left', 'EQ_OP', 'NE_OP', 'LT_OP', 'LE_OP', 'GT_OP', 'GE_OP'),
        ('left', 'ADD_OP', 'SUB_OP'),
        ('left', 'MUL_OP', 'DIV_OP'),
    )

    def __init__(self):
        """
        Initializes the parser.
        - Creates an instance of the Lexer for tokenizing input.
        - Builds the parser using PLY.
        """

        self.lexer = Lexer()
        self.parser = yacc.yacc(module=self)

    def parse(self, data):
        """
        Parses the given input data (source code) and returns its AST representation.

        Args:
            data (str): The source code to parse.

        Returns:
            dict: An abstract syntax tree (AST) representation of the program.
        """

        return self.parser.parse(data, lexer=self.lexer.lexer)

    def p_start(self, p):
        '''start : PROGRAM_KW IDENTIFIER SEMICOLON decList funcList block'''
        p[0] = {'type': 'program', 'id': p[2], 'decList': p[4], 'funcList': p[5], 'block': p[6]}
    
    def p_decList_1(self, p):
        '''decList : decs'''
        p[0] = {'type': 'decList', 'decs': p[1], 'decList': None}

    def p_decList_2(self, p):
        '''decList : decs decList'''
        p[0] = {'type': 'decList', 'decs': p[1], 'decList': p[2]}

    def p_decs_1(self, p):
        '''decs : type varList SEMICOLON'''
        p[0] = {'type': 'decs', 'type_node': p[1], 'varList': p[2]}

    def p_decs_2(self, p):
        '''decs : empty'''
        p[0] = {'type': 'decs', 'empty': True}

    def p_type_1(self, p):
        '''type : INTEGER_KW'''
        p[0] = {'type': 'type', 'typeName': 'integer'}

    def p_type_2(self, p):
        '''type : REAL_KW'''
        p[0] = {'type': 'type', 'typeName': 'real'}

    def p_type_3(self, p):
        '''type : BOOLEAN_KW'''
        p[0] = {'type': 'type', 'typeName': 'boolean'}

    def p_varList_1(self, p):
        '''varList : IDENTIFIER'''
        p[0] = {'type': 'varList', 'varList': None, 'identifier': p[1]}
    
    def p_varList_2(self, p):
        '''varList : varList COMMA IDENTIFIER'''
        p[0] = {'type': 'varList', 'varList': p[1], 'identifier': p[3]}

    def p_funcList_1(self, p):
        '''funcList : funcList funcDec'''
        p[0] = {'type': 'funcList', 'funcList': p[1], 'funcDec': p[2]}

    def p_funcList_2(self, p):
        '''funcList : empty'''
        p[0] = {'type': 'funcList', 'empty': True}

    def p_funcDec(self, p):
        '''funcDec : FUNCTION_KW IDENTIFIER parameters COLON type decList block'''
        p[0] = {'type': 'funcDec', 'id': p[2], 'parameters': p[3], 'returnType': p[5], 'decList': p[6], 'block': p[7]}

    def p_parameters(self, p):
        '''parameters : LEFT_PA decList RIGHT_PA'''
        p[0] = {'type': 'parameters', 'decList': p[2]}

    def p_block(self, p):
        '''block : BEGIN_KW stmtList END_KW'''
        p[0] = {'type': 'block', 'stmtList': p[2]}

    def p_stmtList_1(self, p):
        '''stmtList : stmt'''
        p[0] = {'type': 'stmtList', 'stmtList': None, 'stmt': p[1]}

    def p_stmtList_2(self, p):
        '''stmtList : stmtList stmt'''
        p[0] = {'type': 'stmtList', 'stmtList': p[1], 'stmt': p[2]}

    def p_stmt_1(self, p):
        '''stmt : IDENTIFIER ASSIGN_OP expr SEMICOLON'''
        p[0] = {'type': 'stmt', 'stmtType': 'assign', 'id': p[1], 'expr': p[3]}

    def p_stmt_2(self, p):
        '''stmt : IF_KW expr THEN_KW stmt'''
        p[0] = {'type': 'stmt', 'stmtType': 'if_then', 'expr': p[2], 'then_stmt': p[4]}

    def p_stmt_3(self, p):
        '''stmt : IF_KW expr THEN_KW stmt ELSE_KW stmt'''
        p[0] = {'type': 'stmt', 'stmtType': 'if_then_else', 'expr': p[2], 'then_stmt': p[4], 'else_stmt': p[6]}

    def p_stmt_4(self, p):
        '''stmt : WHILE_KW expr DO_KW stmt'''
        p[0] = {'type': 'stmt', 'stmtType': 'while', 'expr': p[2], 'stmt': p[4]}

    def p_stmt_5(self, p):
        '''stmt : FOR_KW IDENTIFIER ASSIGN_OP expr TO_KW expr DO_KW stmt'''
        p[0] = {'type': 'stmt', 'stmtType': 'for', 'id': p[2], 'start_expr': p[4], 'end_expr': p[6], 'stmt': p[8]}

    def p_stmt_6(self, p):
        '''stmt : RETURN_KW expr SEMICOLON'''
        p[0] = {'type': 'stmt', 'stmtType': 'return', 'expr': p[2]}

    def p_stmt_7(self, p):
        '''stmt : block'''
        p[0] = {'type': 'stmt', 'stmtType': 'block', 'block': p[1]}

    def p_expr_1(self, p):
        '''expr : expr AND_KW expr'''
        p[0] = {'type': 'expr', 'exprType': 'binary_op', 'op': 'and', 'left': p[1], 'right': p[3]}

    def p_expr_2(self, p):
        '''expr : expr OR_KW expr'''
        p[0] = {'type': 'expr', 'exprType': 'binary_op', 'op': 'or', 'left': p[1], 'right': p[3]}

    def p_expr_3(self, p):
        '''expr : expr MUL_OP expr'''
        p[0] = {'type': 'expr', 'exprType': 'binary_op', 'op': '*', 'left': p[1], 'right': p[3]}

    def p_expr_4(self, p):
        '''expr : expr DIV_OP expr'''
        p[0] = {'type': 'expr', 'exprType': 'binary_op', 'op': '/', 'left': p[1], 'right': p[3]}

    def p_expr_5(self, p):
        '''expr : expr ADD_OP expr'''
        p[0] = {'type': 'expr', 'exprType': 'binary_op', 'op': '+', 'left': p[1], 'right': p[3]}

    def p_expr_6(self, p):
        '''expr : expr SUB_OP expr'''
        p[0] = {'type': 'expr', 'exprType': 'binary_op', 'op': '-', 'left': p[1], 'right': p[3]}

    def p_expr_7(self, p):
        '''expr : expr relop expr'''
        p[0] = {'type': 'expr', 'exprType': 'rel_op', 'op': p[2], 'left': p[1], 'right': p[3]}

    def p_expr_8(self, p):
        '''expr : LEFT_PA expr RIGHT_PA'''
        p[0] = p[2]

    def p_expr_9(self, p):
        '''expr : INTEGER_NUMBER'''
        p[0] = {'type': 'expr', 'exprType': 'literal', 'literalType': 'integer', 'value': p[1]}

    def p_expr_10(self, p):
        '''expr : REAL_NUMBER'''
        p[0] = {'type': 'expr', 'exprType': 'literal', 'literalType': 'real', 'value': p[1]}

    def p_expr_11(self, p):
        '''expr : TRUE_KW'''
        p[0] = {'type': 'expr', 'exprType': 'literal', 'literalType': 'boolean', 'value': True}

    def p_expr_12(self, p):
        '''expr : FALSE_KW'''
        p[0] = {'type': 'expr', 'exprType': 'literal', 'literalType': 'boolean', 'value': False}

    def p_expr_13(self, p):
        '''expr : IDENTIFIER LEFT_PA actualparamlist RIGHT_PA'''
        p[0] = {'type': 'expr', 'exprType': 'function_call', 'id': p[1], 'actualParamList': p[3]}

    def p_expr_14(self, p):
        '''expr : IDENTIFIER'''
        p[0] = {'type': 'expr', 'exprType': 'id', 'id': p[1]}

    def p_actualparamlist_1(self, p):
        '''actualparamlist : expr'''
        p[0] = {'type': 'actualparamlist', 'actualParamList': [p[1]]}

    def p_actualparamlist_2(self, p):
        '''actualparamlist : actualparamlist COMMA expr'''
        p[0] = {'type': 'actualparamlist', 'actualParamList': p[1]['actualParamList'] + [p[3]]}

    def p_actualparamlist_3(self, p):
        '''actualparamlist : IDENTIFIER'''
        p[0] = {'type': 'actualparamlist', 'actualParamList': [ {'type': 'expr', 'exprType': 'id', 'id': p[1]} ] }

    def p_actualparamlist_4(self, p):
        '''actualparamlist : empty'''
        p[0] = {'type': 'actualparamlist', 'actualParamList': []}

    def p_relop_1(self, p):
        '''relop : LT_OP'''
        p[0] = '<'

    def p_relop_2(self, p):
        '''relop : LE_OP'''
        p[0] = '<='

    def p_relop_3(self, p):
        '''relop : EQ_OP'''
        p[0] = '='

    def p_relop_4(self, p):
        '''relop : NE_OP'''
        p[0] = '<>'

    def p_relop_5(self, p):
        '''relop : GE_OP'''
        p[0] = '>='

    def p_relop_6(self, p):
        '''relop : GT_OP'''
        p[0] = '>'

    def p_empty(self, p):
        '''empty : '''
        p[0] = None

    def p_error(self, p):
        if p:
            print(f"Syntax error at token '{p.type}' (value '{p.value}') on line {p.lineno}")
            self.parser.errok() 
        else:
            print("Syntax error at EOF")